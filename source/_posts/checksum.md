---
title: 协议校验和checksum
date: 2019-10-05 10:30:36
tags: 计算机网络
---



IPv4，UDP，TCP等头部中都有一个16位（2字节）的**校验和**字段，用于差错检测，它能以相当高的概率确定接受到的消息是否与发送的相匹配。

## 计算方式

1. 对指定数据以16位分组，依次想加。
2. 如果产生进位（第17位为1），则去掉，且末位加1。
3. 最终结果取反就是校验和的值。

* 发送方计算校验和字段时，校验和字段时置位0；
* 接收方将全部数据（包括校验和）加在一起，如果没有引入差错，则和为FFFF。如果任何比特之一为0，则表示出现了差错。

### IP协议

* IPv4协议头部校验和字段仅计算**IPv4头部20个字节**，意味着IP协议不检查IPv4数据报有效载荷的正确性。意味着上层协议（TCP，UDP）需通过自己的数据完整性校验机制。
* IPv6头部没有任何校验和字段。(1. 光纤传输位出错比较少见 2. 上层协议计算自己的校验和)
* IPv4数据报经过一台路由器，TTL字段减一带来的结果是其头部校验和必须改变。

### IPv4校验和例子

![ip-checksum](/Users/yangqiong/Github/yangqiong.github.io/source/images/ip-checksum.png)

IP头部分别为：0x4502, 0x00a8, 0x156a, 0x4000, 0x3006, 0x71ab（校验和）, 0xa3b1, 0x5e77, 0xc0a8, 0x0068

发送端计算校验和：

0x4502 + 0x00a8 = 0x45aa

0x45aa + 0x156a = 0x5b14

0x5b14 + 0x4000 = 0x9b14

0x9b14 + 0x3006 = 0xcb1a

0xcb1a + 0x0000（校验和置位0）= 0xcb1a

0xcb1a + 0xa3b1 = 0x16ecb，产生进位去掉，末位加1，0x6ecc

0x6ecc + 0x5e77 = 0xcd43

0xcd43 + 0xc0a8 = 0x18deb，产生进位去掉，末位加1，0x8dec

0x8dec + 0x0068 = 0x8e54, 最终取反得到校验和：0x71ab 

或者

0x4502 + 0x00a8 + 0x156a + 0x4000 + 0x3006 + 0xa3b1 + 0x5e77 + 0xc0a8 + 0x0068 = 0x28e52

末位加上进位0x8e52 + 0x2 = 0x8e64，最终取反得到校验和：0x71ab 

接收端校验校验和：

0x8e57 + 0x71ab = 0xFFFF，全为1，表示无差错。



### UDP协议

UDP协议头部校验和字段计算包括三部分：

1. UDP伪头部：包括从IPv4拿到的源IP地址（16位），目的地IP地址（16位），零（2位）+UDP协议号17（4位）+ UDP长度（8位）
2. UDP头部
3. UDP数据（末位补0填充满16位的整数倍）

